---
title: "DP LIS(최장증가수열) + lower_bound 사용"
categories: Algorithm
comments: true
---

## 사용언어
 > Visual studio 2019 C++ 


## 유형
  > 다이나믹 프로그래밍 - LIS(최장증가수열)



<https://leleluv1122.github.io/algorithm/LIS/> 의 2탄으로...  
저번에 설명했던 LIS는 10만 이하의 수에서 시간초과가 나지않은 풀이였다.

이번에는 10만이 넘어갈때에 풀이를 설명하고자 한다.  
먼저, lower_bound를 알아야 한다.

## lower_bound
 - lower_bound는 `#include <algorithm>` 에 포함되어있는 함수이다.
 - 이진탐색(Binary Search)기반의 탐색 방법이다.
 - 찾으려는 key값이 **없으면** key값보다 큰 가장 작은 정수의 값을 찾음.


## 배열 LIS 풀이

```c++
int dp[10];
int arr[9] = { 0, 1, 6, 2, 5, 7, 3, 5, 6 }; // 0은 포함하지 않음

int len = 1;
dp[1] = arr[1];

for (int i = 1; i < 9; i++) {
	if (dp[len] < arr[i]) {
		dp[++len] = arr[i];
		continue;
	}

	int idx = lower_bound(dp + 1, dp + len + 1, arr[i]) - dp;
	dp[idx] = arr[i];
}

cout << len << endl;
for (int i = 1; i <= len; i++)
	cout << dp[i] << " ";
```


## vector LIS 풀이

```c++
vector<int> dp;
vector<int> v;
int arr[8] = {1, 6, 2, 5, 7, 3, 5, 6 };

for (int i = 0; i < 8; i++)
	v.push_back(arr[i]);
	
dp.push_back(v[0]);

for (int i = 1; i < 8; i++) {
	if (dp.back() < v[i]) {
		dp.push_back(v[i]);
		continue;
	}

	auto it = lower_bound(dp.begin(), dp.end(), v[i]);
	*it = v[i];
}

cout << dp.size() << endl;
for (int i = 0; i < dp.size(); i++)
	cout << dp[i] << " ";
```


이렇게 하면 N의 개수가 10만이 넘어가도 시간초과가 나지않게 풀이를 작성할 수 있다.


## 백준 LIS + lower_bound 문제
 - 1365 [꼬인 전깃줄](https://www.acmicpc.net/problem/1365)  
   [1365 풀이](https://github.com/leleluv1122/Algorithm/blob/master/_BAEKJOON_/_BAEKJOON_/1365_%EA%BC%AC%EC%9D%B8_%EC%A0%84%EA%B9%83%EC%A4%84.cpp)  
 - 2352 [반도체 설계](https://www.acmicpc.net/problem/2352)  
   [2352 풀이](https://github.com/leleluv1122/Algorithm/blob/master/_BAEKJOON_/_BAEKJOON_/2352_%EB%B0%98%EB%8F%84%EC%B2%B4_%EC%84%A4%EA%B3%84.cpp)  
 - 2568 [전깃줄 - 2](https://www.acmicpc.net/problem/2568)  
   [2568 풀이](https://github.com/leleluv1122/Algorithm/blob/master/_BAEKJOON_/_BAEKJOON_/2568_%EC%A0%84%EA%B9%83%EC%A4%842.cpp)



